rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to make rules cleaner and more readable.
    function isSignedIn() {
      return request.auth != null;
    }

    function isUser(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function getGame(gameId) {
      return get(/databases/$(database)/documents/game_rooms/$(gameId)).data;
    }

    //----------------------------------------------------------------------
    //  USERS Collection
    //----------------------------------------------------------------------
    match /users/{userId} {
      // Anyone can create their own user document during registration.
      allow create: if true;

      // Users can read their own data and any public data of other users.
      allow get: if isSignedIn();

      // Users can only update their own document.
      // Certain fields like 'balance' or 'role' are protected and can only be changed
      // through validated transactions (defined in other rules).
      allow update: if isUser(userId)
                    && !('balance' in request.resource.data)
                    && !('marketingBalance' in request.resource.data)
                    && !('role' in request.resource.data)
                    && !('wins' in request.resource.data);

      // Users should not be able to delete their own accounts from the app directly.
      allow delete: if false;

      // Allow listing users for features like leaderboards and search.
      allow list: if isSignedIn();
    }

    //----------------------------------------------------------------------
    //  TRANSACTIONS Collection
    //----------------------------------------------------------------------
    match /transactions/{transactionId} {
      // Allow reading transactions only for the user they belong to, or by an admin.
      allow get, list: if isSignedIn() && (
        resource.data.userId == request.auth.uid
      );

      // Allow creating transactions under specific conditions (e.g., within a game join).
      // Direct creation is disallowed to prevent fraud. Creation is handled by game logic.
      allow create: if false;

      // Transactions are immutable.
      allow update, delete: if false;
    }


    //----------------------------------------------------------------------
    //  GAME_ROOMS Collection
    //----------------------------------------------------------------------
    match /game_rooms/{roomId} {
      allow get, list: if isSignedIn();

      // Allow creating a game room if the user is authenticated and the creator.
      allow create: if isSignedIn()
                    && request.resource.data.createdBy.uid == request.auth.uid
                    && request.resource.data.players[0] == request.auth.uid;

      // Allow updates under specific, controlled circumstances.
      allow update: if isSignedIn() &&
                       // Case 1: A player is joining a waiting game.
                       (isJoiningGame(roomId)) ||
                       // Case 2: A player is making a move in an ongoing game.
                       (isMakingMove(roomId)) ||
                       // Case 3: A player is resigning from an ongoing game.
                       (isResigning(roomId));

      // Allow a user to delete a room they created only if it's still waiting for an opponent.
      allow delete: if isSignedIn()
                     && resource.data.status == 'waiting'
                     && resource.data.createdBy.uid == request.auth.uid;

      // CHAT subcollection within a game room
      match /messages/{messageId} {
        // Only players in the game can read or send messages.
        allow read, create: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/game_rooms/$(roomId)).data.players;
      }
    }

    // --- GAME_ROOMS HELPER FUNCTIONS ---

    function isJoiningGame(roomId) {
      let game = getGame(roomId);
      let nextGame = request.resource.data;
      let userBalance = getUserData(request.auth.uid).balance;
      let creatorBalance = getUserData(game.createdBy.uid).balance;

      return game.status == 'waiting'
             && nextGame.status == 'in-progress'
             && game.players.size() == 1
             && nextGame.players.size() == 2
             && request.auth.uid in nextGame.players
             && request.auth.uid != game.createdBy.uid
             && nextGame.player2.uid == request.auth.uid
             && userBalance >= game.wager; // Ensure joiner has enough funds
    }

    function isMakingMove(roomId) {
        let game = getGame(roomId);
        let nextGame = request.resource.data;
        let activePlayerId = game.currentPlayer == game.createdBy.color ? game.createdBy.uid : game.player2.uid;

        return game.status == 'in-progress'
               && request.auth.uid == activePlayerId // Only the current player can make a move
               && nextGame.currentPlayer != game.currentPlayer; // The turn must change
    }

    function isResigning(roomId) {
      let game = getGame(roomId);
      let nextGame = request.resource.data;
      let opponentId = game.players.filter(p => p != request.auth.uid)[0];

      return game.status == 'in-progress'
             && nextGame.status == 'completed'
             && request.auth.uid in game.players
             && nextGame.winner.resignerId == request.auth.uid
             && nextGame.winner.uid == opponentId;
    }


    //----------------------------------------------------------------------
    //  FRIEND_REQUESTS Collection
    //----------------------------------------------------------------------
    match /friend_requests/{requestId} {
      allow get: if isSignedIn() && (request.auth.uid == resource.data.fromId || request.auth.uid == resource.data.toId);
      allow list: if isSignedIn();

      // Allow creating a request if the sender is the current user.
      allow create: if isUser(request.resource.data.fromId);
      // Allow the sender to cancel their own request.
      allow delete: if isUser(resource.data.fromId);
    }

    //----------------------------------------------------------------------
    //  CHATS Collection
    //----------------------------------------------------------------------
    match /chats/{chatId} {
      // A chat document can only be read or created by one of the participants.
      // The chatId is a composite of the two user UIDs, so we can check if the user's UID is in the ID.
      allow get, create: if isSignedIn() && request.auth.uid in chatId.split('_');

      // Allow updates to the chat document (e.g., lastMessage, hasUnread) by participants.
      allow update: if isSignedIn() && request.auth.uid in resource.data.users;
      
      // CHAT MESSAGES subcollection
      match /messages/{messageId} {
         // Only participants of the chat can read or create messages.
         allow read, create: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.users;
      }
    }

    //----------------------------------------------------------------------
    //  NOTIFICATIONS Collection
    //----------------------------------------------------------------------
    match /notifications/{notificationId} {
        // Can only be created by server-side logic (friend requests, etc.).
        allow create: if false;
        // User can only read or update their own notifications.
        allow get, list, update: if isUser(resource.data.userId);
    }
    
    //----------------------------------------------------------------------
    //  MARKETING_APPLICATIONS Collection
    //----------------------------------------------------------------------
    match /marketing_applications/{appId} {
      // Anyone can create an application.
      allow create: if true;
      // Only admins can read/update them.
      allow get, list, update: if isSignedIn() && getUserData(request.auth.uid).role == 'admin';
    }
  }
}
