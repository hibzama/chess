rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function getDoc(path) {
      return get(path).data;
    }
    
    function incomingDoc(path) {
        return request.resource.data;
    }

    // USER-RELATED RULES
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if !isSignedIn() || isOwner(userId); // Allow on signup
      allow update: if isOwner(userId) 
                      || isAcceptingFriendRequest(userId)
                      || isJoiningGameAndPayingWager(userId);
    }

    // FRIEND REQUESTS
    match /friend_requests/{requestId} {
      allow read, create: if isSignedIn();
      allow delete: if isSignedIn() && (
                      // Allow sender to cancel
                      resource.data.fromId == request.auth.uid ||
                      // Allow receiver to delete (implicitly via accept/decline)
                      resource.data.toId == request.auth.uid
                    );
    }
    
    function isAcceptingFriendRequest(otherUserId) {
        let req = request.writeFields;
        return req.size() == 2 // Expecting two writes: one to each user's 'friends' array
            && req[0].toString().endsWith('friends') 
            && req[1].toString().endsWith('friends')
            && request.auth.uid != otherUserId; // Can't accept your own request
    }

    // GAME ROOMS
    match /game_rooms/{roomId} {
      allow read, create: if isSignedIn();
      allow update: if isSignedIn() && isJoiningGame(roomId);
      allow delete: if isSignedIn() && resource.data.createdBy.uid == request.auth.uid; // Creator can cancel waiting room
      
       match /messages/{messageId} {
        allow read, create: if isSignedIn() && request.auth.uid in resource.data.players;
      }
    }
    
    function isJoiningGame(roomId) {
        let roomData = getDoc(/databases/$(database)/documents/game_rooms/$(roomId));
        let incomingRoomData = incomingDoc(/databases/$(database)/documents/game_rooms/$(roomId));
        
        // Ensure the status is changing from 'waiting' to 'in-progress'
        let isStatusUpdate = roomData.status == 'waiting' && incomingRoomData.status == 'in-progress';
        
        // Ensure the user joining is the one making the request and is not the creator
        let isJoiner = incomingRoomData.player2.uid == request.auth.uid && roomData.createdBy.uid != request.auth.uid;
        
        // Ensure players array is correctly updated
        let isPlayerArrayUpdate = incomingRoomData.players.size() == 2 && incomingRoomData.players[0] == roomData.createdBy.uid && incomingRoomDeta.players[1] == request.auth.uid;

        return isStatusUpdate && isJoiner && isPlayerArrayUpdate;
    }
    
    function isJoiningGameAndPayingWager(userId) {
        // This function is called when updating a user document.
        // It's part of the join game transaction. We allow the balance to be decremented.
        let isDecrementingBalance = 'balance' in request.resource.data && request.resource.data.balance < resource.data.balance;
        
        // We can't easily check the full transaction here, but we rely on the fact that
        // this is part of a transaction that is validated by the `isJoiningGame` rule on the game_room document.
        // This is a simplification that assumes the transaction is atomic and validated elsewhere.
        return isSignedIn() && isDecrementingBalance;
    }

    // TRANSACTIONS
    match /transactions/{transactionId} {
        allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
        // Creation of transactions is handled by the functions below
        allow create: if isSignedIn() && (
                        isCreatingWager(transactionId) ||
                        isCreatingDeposit(transactionId) ||
                        isCreatingWithdrawal(transactionId) ||
                        isCreatingMarketingWithdrawal(transactionId)
                      );
    }
    
    function isCreatingWager(transactionId) {
        let wager = incomingDoc(/databases/$(database)/documents/transactions/$(transactionId));
        return wager.type == 'wager' && wager.userId == request.auth.uid;
    }

    function isCreatingDeposit(transactionId) {
        let deposit = incomingDoc(/databases/$(database)/documents/transactions/$(transactionId));
        return deposit.type == 'deposit' && deposit.userId == request.auth.uid;
    }

    function isCreatingWithdrawal(transactionId) {
        let withdrawal = incomingDoc(/databases/$(database)/documents/transactions/$(transactionId));
        let user = getDoc(/databases/$(database)/documents/users/$(request.auth.uid));
        return withdrawal.type == 'withdrawal' 
            && withdrawal.userId == request.auth.uid
            && user.balance >= withdrawal.amount;
    }
    
    function isCreatingMarketingWithdrawal(transactionId) {
        let withdrawal = incomingDoc(/databases/$(database)/documents/transactions/$(transactionId));
        let user = getDoc(/databases/$(database)/documents/users/$(request.auth.uid));
        return withdrawal.type == 'marketing_withdrawal' 
            && withdrawal.userId == request.auth.uid
            && user.marketingBalance >= withdrawal.amount;
    }


    // NOTIFICATIONS & ADMIN-ONLY SECTIONS
    match /notifications/{notificationId} {
        allow read, create: if isSignedIn();
        allow update: if isSignedIn() && isOwner(resource.data.userId);
    }

    match /marketing_applications/{appId} {
        allow create: true; // Anyone can apply
        allow read, update: if get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }
    
    // PUBLIC READS
    match /public_config/{docId} {
      allow read: if true;
    }
  }
}
