rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isUserAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    // isAcceptingFriendRequest: Validates the transaction for accepting a friend request.
    // This is a complex transaction that writes to 3 documents:
    // 1. Updates the friend_requests document status to 'accepted'.
    // 2. Updates the current user's (acceptor's) 'friends' array.
    // 3. Updates the other user's (requester's) 'friends' array.
    function isAcceptingFriendRequest(userId) {
      let requestDoc = getAfter(/databases/$(database)/documents/friend_requests/$(request.id)).data;
      let otherUserUpdates = request.resource.data.diff(resource.data).affectedKeys();

      // Ensures this rule only applies when updating the OTHER user's document
      return isUserAuthenticated()
        && !isOwner(userId)
        // Check that the write is an update to the 'friends' array
        && otherUserUpdates.hasOnly(['friends'])
        // Check that a friend_requests document is being updated in the same transaction
        && existsAfter(/databases/$(database)/documents/friend_requests/$(request.id))
        // Verify the friend request is being accepted, not just any status change
        && requestDoc.status == 'accepted'
        // Verify the current user is the one accepting the request
        && requestDoc.toId == request.auth.uid
        // Verify the document being updated belongs to the user who sent the request
        && requestDoc.fromId == userId;
    }

    // isJoiningGame: Validates the complex transaction when a user joins a game.
    // This transaction can read/write multiple documents:
    // - Reads: game_room, both users, potentially referrer users.
    // - Writes: game_room (status, player2), both users (balance), and new transaction documents.
    function isJoiningGame(userId) {
      // Find the game room ID from the transaction's writes.
      let gameRoomId = request.write.find(w => w.path.matches('/databases/$(database)/documents/game_rooms/.*')).path.split('/').pop();
      let gameRoom = get(/databases/$(database)/documents/game_rooms/$(gameRoomId)).data;
      
      return isUserAuthenticated()
        && !isOwner(userId) // This rule is for updating the *other* player's balance
        && gameRoomId != null // A game room must be part of the transaction
        && gameRoom.status == 'waiting' // Can only join a waiting room
        && gameRoom.wager > 0 // Only applies to wagered games
        // The user being updated must be the creator of the room
        && gameRoom.createdBy.uid == userId
        // The user performing the write must be the one joining as player 2
        && getAfter(/databases/$(database)/documents/game_rooms/$(gameRoomId)).data.player2.uid == request.auth.uid;
    }

    // Collections
    match /users/{userId} {
      // Anyone can read user profiles (for names, ranks, etc.)
      allow read: if isUserAuthenticated();
      
      // A user can create their own account
      allow create: if isOwner(userId);

      // A user can update their own document, OR another user's document
      // only in the specific context of accepting a friend request or joining a game.
      allow update: if isOwner(userId) || isAcceptingFriendRequest(userId) || isJoiningGame(userId);

      // Only admins can delete user accounts
      allow delete: if isAdmin();
    }

    match /game_rooms/{roomId} {
      allow read: if isUserAuthenticated();
      allow create: if isUserAuthenticated() && request.resource.data.createdBy.uid == request.auth.uid;
      
      // Updates are allowed if the user is a player in the game.
      // Or if the joining player is moving the status from 'waiting' to 'in-progress'.
      allow update: if request.auth.uid in resource.data.players
                      || (resource.data.status == 'waiting' && request.resource.data.status == 'in-progress');

      // The user who created the room can delete it only if it's still waiting.
      allow delete: if resource.data.createdBy.uid == request.auth.uid && resource.data.status == 'waiting';
    }

    match /chats/{chatId} {
      allow read, write: if isUserAuthenticated() && request.auth.uid in resource.data.users;
      
      match /messages/{messageId} {
        allow read, write: if isUserAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.users;
      }
    }

    match /friend_requests/{requestId} {
      allow read: if isUserAuthenticated() && (isOwner(resource.data.fromId) || isOwner(resource.data.toId));
      allow list: if isUserAuthenticated() && request.query.where.toId == request.auth.uid;
      allow create: if isOwner(request.resource.data.fromId);
      allow update, delete: if isOwner(resource.data.fromId) || isOwner(resource.data.toId);
    }

    match /transactions/{transactionId} {
      allow read, list: if isUserAuthenticated() && resource.data.userId == request.auth.uid || isAdmin();
      // Transactions are created via transactions, not direct writes.
      allow create: if isUserAuthenticated();
      allow update, delete: if isAdmin();
    }
    
    match /marketing_applications/{appId} {
      allow create: if true;
      allow read, update, delete: if isAdmin();
    }
    
    match /notifications/{notificationId} {
      allow read, list, update: if isUserAuthenticated() && resource.data.userId == request.auth.uid;
      // Notifications are created by backend functions or as part of transactions
      allow create: if isUserAuthenticated() || isAdmin();
      allow delete: if isAdmin();
    }
  }
}